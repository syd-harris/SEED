#include "Arduino.h"

//DISTANCE AND ROTATION SETPOINTS ARE IN SETUP()

const double PI_VALUE = 3.1415926535897932;
// const double CIRCLE_RADIUS = 0.36807692l;
const double CIRCLE_RADIUS = 0.3048;

// variables for computation
float counter = 0;
bool docounting = false;

// varaibles for serial communication
String InputString = ""; // a string to hold incoming data
bool StringComplete = false;

// PINS
int encoderM1_A = 2; //interrupt pins
int encoderM2_A = 3; //interrupt pins
int D2 = 4;     // disables both outputs of motor channels when LOW; toggling resets latched driver fault condition
int encoderM1_B = 5;
int encoderM2_B = 6;
int M1DIR = 7;  // Motor 1 direction output
int M2DIR = 8;  // Motor 2 direction output
int M1PWM = 9;  // Motor 1 PWM speed output
int M2PWM = 10; // Motor 2 PWM speed output
int SF = 12;    // Status flag indicator (LOW = fault)



// CONSTANTS
const int encoderCountsPerRev = 64 * 50;
const float WHEEL_RADIUS = 0.1512/2; //0.1476375/2; // m (5.8125 in diameter)
const float WHEEL_DISTANCE = 0.29; //0.282575; // m (11.125 in)


int speed1 = 0; // Motor 1 speed percentage
int speed2 = 0; // Motor 2 speed percentage
int dir1 = 1;
int dir2 = 1;


// VARIABLES
int posM1raw_intPinOnly = 0;
int posM1raw = 0; //raw encoder counts
int encoderM1_AState = 0;
int encoderM1_BState = 0;
unsigned long encoderM1_ISR_time = 0;
unsigned long encoderM1_ISR_timeLast = 0;
double posM1 = 0; //position in Radians
double velocityM1 = 0; //rads / seconds
double posM1_old = 0;
double posM1Setpoint = 0; //position SP in radians
int posM2raw_intPinOnly = 0;
int posM2raw = 0; //raw encoder counts
int encoderM2_AState = 0;
int encoderM2_BState = 0;
unsigned long encoderM2_ISR_time = 0;
unsigned long encoderM2_ISR_timeLast = 0;
double posM2 = 0; //position in Radians
double velocityM2 = 0; //rads / seconds
double posM2_old = 0;
double posM2Setpoint = 0; //position SP in radians


double velocityRobotLinear = 0; // m/s
double velocityRobotRotational = 0; // rad/s


// Groe PID
double positionRobotLinear = 0;
double velocityRobotLinearSP = 0;
double velocityRobotLinearError = 0;
double velocityRobotLinearError_past = 0;

const int roePID_Kp = 16;
const int roePID_Ki = 358;
const int roePID_Kd = 15000;
double roePID_D = 0;
double roePID_I = 0;
double roePID_e_past = 0;
double roePID_u = 0;
int roePID_umax = 50; // SHOULD BE 200


// PID for Groe PID

double positionRobotLinearSP = 0;
double positionRobotLinearError = 0;
double positionRobotLinearError_past = 0;

const int roeroePID_Kp = 100;
const int roeroePID_Ki = 1407;
const int roeroePID_Kd = 1;
double roeroePID_D = 0;
double roeroePID_I = 0;
double roeroePID_e_past = 0;
double roeroePID_u = 0;
const int roeroePID_umax = 5; //m/s robot top speed


//Gphi PID
double velocityRobotRotationalSP = 0;
double velocityRobotRotationalError = 0;
double velocityRobotRotationalError_past = 0;

const int phiPID_Kp = 2;
const int phiPID_Ki = 83;
const int phiPID_Kd = 2000;
double phiPID_D = 0;
double phiPID_I = 0;
double phiPID_e_past = 0;
double phiPID_u = 0;
const int phiPID_umax = 50; // SHOULD BE 200


double positionRobotRotational = 0;
double positionRobotRotationalSP = 0;
double positionRobotRotationalError = 0;
double positionRobotRotationalError_past = 0;

const int phiphiPID_Kp = 10;
const int phiphiPID_Ki = 17;
const int phiphiPID_Kd = 10000;
double phiphiPID_D = 0;
double phiphiPID_I = 0;
double phiphiPID_e_past = 0;
double phiphiPID_u = 0;
const int phiphiPID_umax = 7;


double V_hat = 0;
double V_delta = 0;


double time_now = 0;
double period = 5; //milliseconds
double timeStart = 4294967296;
bool timeFlag = false;

int robotState = 0;
double markerDetected = 0;

double beaconDistance = 0;
double beaconAngle = 0;

double marker = 0;

int flag = 0;
double timeFlagged = 0;

String rxString = "";
String strArr[3]; //Set the size of the array to equal the number of values you will be receiveing.

void setup() {
  // put your setup code here, to run once:
  pinMode(encoderM1_A, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(encoderM1_A), encoderM1_ISR, CHANGE);
  pinMode(encoderM1_B, INPUT_PULLUP);
  pinMode(encoderM2_A, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(encoderM2_A), encoderM2_ISR, CHANGE);
  pinMode(encoderM2_B, INPUT_PULLUP);
  pinMode(D2, OUTPUT);
  pinMode(M1DIR, OUTPUT);
  pinMode(M2DIR, OUTPUT);
  pinMode(M1PWM, OUTPUT);
  pinMode(M2PWM, OUTPUT);
  pinMode(SF, INPUT);
  
  Serial.begin(115200);
  // reserve 200 bytes for the inputString:
  InputString.reserve(200);
  //Serial.println("Ready!"); // Let anyone on the other end of the serial line know that Arduino is ready

  positionRobotRotationalSP = 0; // Rotational setpoint in RADIANS.  POSITIVE to go CCW, NEGATIVE to go CW
  positionRobotLinearSP = 1 * 0.3048; // feet * meter/feet.  Distance setpoint in Feet.  POSITIVE to go FORWARD.  NEGATIVE to go BACKWARD.

  flag = 0;
}

void loop() {
  time_now = millis();

  // Arduino Code
  if (Serial.available()) {
    
    //Keep looping until there is something in the buffer.
    while (Serial.available()) {
      //Delay to allow byte to arrive in input buffer.
      delay(2);
      //Read a single character from the buffer.
      char ch = Serial.read();
      //Append that single character to a string.
      rxString+= ch;
    }
    int stringStart = 0;
    int arrayIndex = 0;
    
    for (int i=0; i < rxString.length(); i++) {
      //Get character and check if it's our "special" character.
      if(rxString.charAt(i) == ','){
        //Clear previous values from array.
        strArr[arrayIndex] = "";
        //Save substring into array.
        strArr[arrayIndex] = rxString.substring(stringStart, i);
        //Set new string starting point.
        stringStart = (i+1);
        arrayIndex++;
      }
    }
    
    //Put values from the array into the variables.
    String value1 = strArr[0];
    String value2 = strArr[1];
    String value3 = strArr[2];
    //Convert string to int if you need it.
    markerDetected = value1.toDouble();
    beaconDistance = value2.toDouble();
   // Serial.println(positionRobotRotationalSP);
    beaconAngle = value3.toDouble();
    //Serial.println(positionRobotLinearSP);
  }
 
  posM1raw = -pos(encoderM1_A, encoderM1_B, posM1raw_intPinOnly, encoderM1_AState);
  posM1 = double(posM1raw)/encoderCountsPerRev*2*3.142;
  posM2raw = pos(encoderM2_A, encoderM2_B, posM2raw_intPinOnly, encoderM2_AState);
  posM2 = double(posM2raw)/encoderCountsPerRev*2*3.142;
  velocityRobotLinear = WHEEL_RADIUS * (velocityM1 + velocityM2) / 2;
  
  // positionRobotLinear = -WHEEL_RADIUS * (posM1 + posM2) / 2; // chanve to X and Y

  positionRobotLinear += ((period / 1000) * WHEEL_RADIUS * (velocityM1 + velocityM2)) / 2;
  
  velocityRobotRotational = -WHEEL_RADIUS * (velocityM1 - velocityM2) / WHEEL_DISTANCE;
  
  // positionRobotRotational = WHEEL_RADIUS * (posM1 - posM2) / WHEEL_DISTANCE;

  positionRobotRotational += ((period / 1000) * WHEEL_RADIUS * (velocityM2 - velocityM1)) / WHEEL_DISTANCE;

  switch(robotState) {
  // Rotate robot until the camera detects the marker. Then set the wheel speeds to 0
  case 0:
      if (markerDetected == 0) {
        speed1 = 10;
        speed2 = 10;

        dir1 = 1;
        dir2 = 0;
      }
      else {
        speed1 = 0;
        speed2 = 0;
        if (flag == 0){
          timeFlagged = time_now;
          flag = 1;
        }

        positionRobotRotationalSP = positionRobotRotational + beaconAngle; //beaconAngle;

        if (time_now > timeFlagged + 1000){
          robotState = 1;
        }
      }

      break;
      
  case 1:
      
      if (abs(positionRobotRotationalError) < 0.01) {
        robotState = 2;  
        positionRobotLinearSP = positionRobotLinear + beaconDistance - .10;
        
      }

      break;      

  case 2:
      

      if (abs(positionRobotLinear - positionRobotLinearSP) < 0.01) { //(abs(positionRobotLinearError) < 0.01) {
        positionRobotRotationalSP = positionRobotRotational - PI_VALUE / 2; // COMMENT THIS PART OUT IF WE DONT WANT TO GO IN A CIRCLE
        robotState = 3;
      }
  
      break;

  case 3:

      if (abs(positionRobotRotationalError) < 0.01) {
        
//        circleStart = positionRobotLinear;
        
//        speed1 = 10;
//        speed2 = 23;
//        dir1 = 0;
//        dir2 = 0;

        positionRobotRotationalSP = positionRobotRotational + 6.28;        
        robotState = 4;
      }

      break;
      
  case 4:
      //positionRobotRotationalError = positionRobotRotationalSP - positionRobotRotational;

      if (positionRobotRotational > positionRobotRotationalSP) {
       robotState = 5;
      }

      break;
 
  case 5:
      speed1 = 0;
      speed2 = 0;
      

      break;
      
  }
  
//  Serial.print("Pos SP: ");
//  Serial.println(positionRobotRotationalSP);
//    Serial.print("Pos M1: ");
//  Serial.println(posM1);
//    Serial.print("Pos M2: ");
//  Serial.println(posM2);

  // PID controller for Groe PID
  positionRobotLinearError = positionRobotLinearSP - positionRobotLinear;
  roeroePID_D = (positionRobotLinearError - positionRobotLinearError_past)/period;
  positionRobotLinearError_past = positionRobotLinearError;
  roeroePID_I = roeroePID_I + (period * positionRobotLinearError);
  roeroePID_u = roeroePID_Kp*positionRobotLinearError + roeroePID_Ki*roeroePID_I + roeroePID_Kd*roeroePID_D;
      
  if (abs(roeroePID_u) > roeroePID_umax){
    int sign_u = 0;
    if (roeroePID_u > 0) sign_u = 1;
    else sign_u = -1;
    roeroePID_u = sign_u * roeroePID_umax;
    int sign_e = 0;
    if (positionRobotLinearError > 0) sign_e = 1;
    else sign_e = -1;
    positionRobotLinearError = sign_e * min(roeroePID_umax/roeroePID_Kp, abs(positionRobotLinearError));
    roeroePID_I = (roeroePID_u - roeroePID_Kp*positionRobotLinearError - roeroePID_Kd*roeroePID_D) / roeroePID_Ki;
  }

  if (robotState == 4) {
    if (positionRobotRotational > positionRobotRotationalSP) velocityRobotLinearSP = 0;
    else velocityRobotLinearSP = -0.65;
  }
  else {
    velocityRobotLinearSP = -roeroePID_u;
  }

  // Groe PID
  velocityRobotLinearError = velocityRobotLinearSP - velocityRobotLinear;
  roePID_D = (velocityRobotLinearError - velocityRobotLinearError_past)/period;
  velocityRobotLinearError_past = velocityRobotLinearError;
  roePID_I = roePID_I + (period * velocityRobotLinearError);
  roePID_u = roePID_Kp*velocityRobotLinearError + roePID_Ki*roePID_I + roePID_Kd*roePID_D;
      
  if (abs(roePID_u) > roePID_umax) {
    int sign_u = 0;
    if (roePID_u > 0) sign_u = 1;
    else sign_u = -1;
    roePID_u = sign_u * roePID_umax;
    int sign_e = 0;
    if (velocityRobotLinearError > 0) sign_e = 1;
    else sign_e = -1;
    velocityRobotLinearError = sign_e * min(roePID_umax/roePID_Kp, abs(velocityRobotLinearError));
    roePID_I = (roePID_u - roePID_Kp*velocityRobotLinearError - roePID_Kd*roePID_D) / roePID_Ki;
  }

  V_hat = roePID_u;

  // PID for Gphi PID
  positionRobotRotationalError = positionRobotRotationalSP - positionRobotRotational;
  phiphiPID_D = (positionRobotRotationalError - positionRobotRotationalError_past)/period;
  positionRobotRotationalError_past = positionRobotRotationalError;
  phiphiPID_I = phiphiPID_I + (period * positionRobotRotationalError);
  phiphiPID_u = phiphiPID_Kp*positionRobotRotationalError + phiphiPID_Ki*phiphiPID_I + phiphiPID_Kd*phiphiPID_D;
      
  if (abs(phiphiPID_u) > phiphiPID_umax){
    int sign_u = 0;
    if (phiphiPID_u > 0) sign_u = 1;
    else sign_u = -1;
    phiphiPID_u = sign_u * phiphiPID_umax;
    int sign_e = 0;
    if (positionRobotRotationalError > 0) sign_e = 1;
    else sign_e = -1;
    // positionRobotRotationalError = sign_e * min(phiphiPID_umax/phiphiPID_Kp, abs(positionRobotRotationalError));
    phiphiPID_I = (phiphiPID_u - phiphiPID_Kp*positionRobotRotationalError - phiphiPID_Kd*phiphiPID_D) / phiphiPID_Ki;
  }

  if (robotState == 4) {
    if (positionRobotRotational > positionRobotRotationalSP) velocityRobotLinearSP = 0;
    else velocityRobotRotationalSP = 0.65;
  }
  else {
    velocityRobotRotationalSP = phiphiPID_u;
  }

  // Gphi PID
  velocityRobotRotationalError = velocityRobotRotationalSP - velocityRobotRotational;
  phiPID_D = (velocityRobotRotationalError - velocityRobotRotationalError_past)/period;
  velocityRobotRotationalError_past = velocityRobotRotationalError;
  phiPID_I = phiPID_I + (period * velocityRobotRotationalError);
  phiPID_u = phiPID_Kp*velocityRobotRotationalError + phiPID_Ki*phiPID_I + phiPID_Kd*phiPID_D;
   
  if (abs(phiPID_u) > phiPID_umax) {
    int sign_u = 0;
    if (phiPID_u > 0) sign_u = 1;
    else sign_u = -1;
    phiPID_u = sign_u * phiPID_umax;
    int sign_e = 0;
    if (velocityRobotRotationalError > 0) sign_e = 1;
    else sign_e = -1;
    velocityRobotRotationalError = sign_e * min(phiPID_umax/phiPID_Kp, abs(velocityRobotRotationalError));
    phiPID_I = (phiPID_u - phiPID_Kp*velocityRobotRotationalError - phiPID_Kd*phiPID_D) / phiPID_Ki;
  }

  V_delta = phiPID_u;     
  if (robotState != 4){
    if (abs(positionRobotRotationalError) < 0.01){
      V_delta = 0;
    }
    if (abs(positionRobotLinearSP - positionRobotLinear) < 0.01){
      V_hat = 0;
    }
  }
  if (robotState != 2 && robotState != 4) V_hat = 0;  // REMOVE THIS.  linear velo

  // SET motor speeds & directions
  if ((robotState != 0) && (robotState != 5)) {
    speed1 = abs((V_hat + V_delta)/2);
    speed2 = abs((V_hat - V_delta)/2);
    if ((V_hat + V_delta)/2 > 0) dir1 = 1;
    else dir1 = 0;
    if ((V_hat - V_delta)/2 > 0) dir2 = 1;
    else dir2 = 0;
  }


     
  digitalWrite(M1DIR, dir1);
  digitalWrite(M2DIR, !dir2);
  if (robotState == 5) digitalWrite(D2, LOW);
  else digitalWrite(D2, HIGH);
  analogWrite(M1PWM, int(speed1*2.55));
  analogWrite(M2PWM, int(speed2*2.55));
     
//

//  Serial.print(counter);
//  Serial.print("\t");
//  Serial.print(velocityRobotRotational);
//  Serial.println("");
//
//  Serial.println(markerDetected);
//  Serial.print(" pos");
//  Serial.println(velocityRobotRotational);
//  Serial.print(" vel");
//Serial.print("\n");
  
  // wait 100 ms
  //delay(100);

  while(millis() < time_now + period);  // delay for length of period
}


void encoderM1_ISR(){
  //on pin A state change, encoder has advanced or returned 2 positions
    encoderM1_ISR_time = micros();
    encoderM1_AState = digitalRead(encoderM1_A);
    encoderM1_BState = digitalRead(encoderM1_B);
    if (encoderM1_AState != encoderM1_BState){
        posM1raw_intPinOnly += 2;
        velocityM1 = float(2)/encoderCountsPerRev*2*3.142/((encoderM1_ISR_time - encoderM1_ISR_timeLast)/float(1000000));
      }
    else{
      posM1raw_intPinOnly -= 2;
      velocityM1 = -float(2)/encoderCountsPerRev*2*3.142/((encoderM1_ISR_time - encoderM1_ISR_timeLast)/float(1000000));
    }
    encoderM1_ISR_timeLast = encoderM1_ISR_time;
}

void encoderM2_ISR(){
  //on pin A state change, encoder has advanced or returned 2 positions
    encoderM2_ISR_time = micros();
    encoderM2_AState = digitalRead(encoderM2_A);
    encoderM2_BState = digitalRead(encoderM2_B);
    if (encoderM2_AState != encoderM2_BState){
        posM2raw_intPinOnly += 2;
        velocityM2 = -float(2)/encoderCountsPerRev*2*3.142/((encoderM2_ISR_time - encoderM2_ISR_timeLast)/float(1000000));
      }
    else{
      posM2raw_intPinOnly -= 2;
      velocityM2 = float(2)/encoderCountsPerRev*2*3.142/((encoderM2_ISR_time - encoderM2_ISR_timeLast)/float(1000000));
    }
    encoderM2_ISR_timeLast = encoderM2_ISR_time;
}

int pos(int pinA, int pinB, int count, int AState) {
  //adjust actual position by -1, 0, +1 depending on current values of pins
  int AStateCur = digitalRead(pinA);
  int BStateCur = digitalRead(pinB);
  if (AStateCur == BStateCur){ // if current AState = BState, the encoder is an indented position.  No need to adjust
     return count;
  }
  else if (AState == 1){
    if (AStateCur == 0){
     return count+1;
    }
    else{
      return count-1;
    }
  }
  else if (AState == 0){
     if (AStateCur == 1){
     return count+1;
    }
    else{
      return count-1;
    }
  }
}
